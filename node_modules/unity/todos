Object traversal
================
Optionally access data structure as an object, i.e.
root.users(5).messages(2).comments as well as
/root/users/5/messages/2/comments

Support simpler definition
==========================
{
  [path]: [resolverObject],
  [path2]: [resolverObject2]
} 
instead of 
[{
  path: [path],
  resolver: resolverObject
}, {
  path: [path2],
  resolver: resolverObject2
}]
What to do about defer? on resolverObject?


Mounting another unity instance
===============================
Adding a second unity instance under a first one
i.e. /a/b/c where c is a unity instance


Fetch tree segment
==================
E.g. fetching b from /a/b/c also resolves and returns c on b
Support 'depth' parameter? Or specifically like '?include=c'


Validate returned objects
=========================
For buffer and stream protocol, throw an error if returned object is not the right type


Declarative filters for returned objects
========================================
i.e. a list of properties to exclude/include


Wildcard mounts
===============
Let mount path match prefix of lookup path, using the remainder to lookup a data structure on returned object, i.e.
path: /a/b/* matching /a/b/c/d, resulting in looking up resource on /a/b and getting /c/d on that
Example: /a/b returns 
{
  c: {
    d: 'hi'
  },
  x: 'something'
}
then /a/b/c/d would return 'hi'. Throw an error if more than one object is returned.
Path definition: /a/b/therest:path ?
/a/b/therest:path/resource (i.e. non-greedy globbing)


Support regexps in path parser
==============================
i.e. :<class> can be defined as a regexp or validator function
/a/b/c:email
where email refers to an email validator


Set defers and defer directions
===============================
Set defers should resolve leaf first then call deferred resolver with output as value


Fixed root
==========
unity.setRoot('/actimo/user/1').get('/tasks') = unity.setRoot('/actimo/user/1/tasks')


Bulk resolving
==============
mapOfLotsOfRequests = {
  [randomId1]: 'GET /some/path',
  [randomId2]: 'SET /some/path someValue',
  ...
}
unity.blk(mapOfLotsOfRequests).then(mapOfLotsOfResolutions);
mapOfLotsOfResolutions = {
  [randomId1]: value1,
  [randomId2]: value2,
  ...
}


Print tree for doc purposes
===========================
- use npm install archy
- construct separate tree for printing out

root
├── a
└─┬ b
  ├─┬ :someId
  │ └─┬ object
  │   └── :property
  └ c
     
- mark actions on nodes (read/write/runnable etc)
